import fs from 'node:fs';
import path from 'node:path';
import { Command } from 'commander';
import v from 'voca';
import { $ } from 'zx';
import { subjectsDefinitions } from '../packages/fuel-streams/src/subjects-def';

const program = new Command();

program
  .name('generate-subjects')
  .description('Generate subject files for Fuel Streams')
  .option(
    '-o, --output <path>',
    'output directory for generated files',
    'packages/fuel-streams/src/data',
  )
  .addHelpText(
    'after',
    `
Example calls:
  $ generate-subjects --output ./custom/output/dir
  $ generate-subjects -o ./src/data`,
  )
  .parse();

const options = program.opts();
const OUTPUT_DIR = path.join(process.cwd(), options.output);

// Create output directory if it doesn"t exist
if (!fs.existsSync(OUTPUT_DIR)) {
  fs.mkdirSync(OUTPUT_DIR, { recursive: true });
  console.log(`Created output directory: ${OUTPUT_DIR}`);
}

function generateSubjectBase() {
  return `/**
 * This file is auto-generated by scripts/generate-subjects.ts
 * Do not edit this file manually
 */

import v from "voca";
import type { DeliverPolicy, ClientMessageSubscribe } from "../ws";

export type GenericRecord = Record<string, any>;

export interface EntityParser<
  T extends GenericRecord,
  R extends GenericRecord,
> {
  parse(data: R): T;
}

export type SubjectMetadata<T extends GenericRecord, R extends GenericRecord> = {
  id: string;
  format: string;
  parser: EntityParser<T, R>;
};

export abstract class SubjectBase<
  TFields extends GenericRecord,
  T extends GenericRecord,
  R extends GenericRecord,
> {
  constructor(protected _fields: Partial<TFields> = {}) {}
  protected abstract metadata: SubjectMetadata<T, R>;

  // This is a hack to make the compiler happy
  _entity(): T {
    return {} as T
  }
  _rawEntity(): R {
    return {} as R;
  }

  get fields(): Partial<TFields> {
    return this._fields;
  }

  get id(): string {
    return this.metadata.id;
  }

  get format(): string {
    return this.metadata.format;
  }

  get parser(): EntityParser<T, R> {
    return this.metadata.parser;
  }

  paramsFromFields(): Record<string, string> {
    return Object.entries(this.fields).reduce<Record<string, string>>(
      (acc, [key, value]) => {
        if (value && value !== "*") {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
  }

  subscriptionPayloadJson(deliverPolicy: DeliverPolicy): ClientMessageSubscribe {
    return {
      subscribe: {
        subject: this.id,
        params: this.paramsFromFields(),
        deliverPolicy: deliverPolicy.toString(),
      },
    };
  }

  parse(): string {
    const fields = Object.entries(this.fields).reduce<Record<string, string>>(
      (acc, [key, value]) => {
        acc[key] = value?.toString() ?? "*";
        return acc;
      },
      {}
    );

    return this.format.replace(
      /\\{([^}]+)\\}/g,
      (_, key: string) => fields[v.camelCase(key)] ?? "*"
    );
  }

  build(fields: Partial<TFields>): this {
    this._fields = { ...this._fields, ...fields };
    return this;
  }

  static build<
    T extends SubjectBase<GenericRecord, GenericRecord, GenericRecord>,
  >(this: new () => T, fields: Partial<Parameters<T["build"]>[0]> = {}): T {
    // biome-ignore lint/complexity/noThisInStatic: <explanation>
    return new this().build(fields);
  }

  static wildcard<
    T extends SubjectBase<GenericRecord, GenericRecord, GenericRecord>,
  >(this: new () => T): string {
    // biome-ignore lint/complexity/noThisInStatic: <explanation>
    return new this().parse();
  }
}`;
}

function mapRustTypeToTS(rustType: string): string {
  const typeMap: Record<string, string> = {
    B256: 'Bytes32',
    usize: 'number',
    u8: 'number',
    u16: 'number',
    u32: 'number',
    u64: 'number',
  };

  return typeMap[rustType] || rustType;
}

function generateInterface(name: string, initFields: Record<string, any>) {
  const fields = Object.entries(initFields)
    .map(([key, value]) => {
      const camelKey = v.camelCase(key);
      return `  ${camelKey}: ${mapRustTypeToTS(value.type)};`;
    })
    .join('\n');

  return `type ${name}Fields = {
${fields}
}`;
}

function generateSubjectImports(moduleConfig: any, entity: string): string {
  const usedTypes = new Set<string>();

  // Add base types for the entity
  usedTypes.add(entity);
  usedTypes.add(`Raw${entity}`);

  // Add types from fields
  if ('variants' in moduleConfig) {
    Object.values(moduleConfig.variants).forEach((variant: any) => {
      getUsedTypes(variant.fields).forEach((type) => usedTypes.add(type));
    });
  } else {
    getUsedTypes(moduleConfig.fields).forEach((type) => usedTypes.add(type));
  }

  // Add type enum based on entity type
  switch (entity) {
    case 'Input':
      usedTypes.add('InputType');
      break;
    case 'Output':
      usedTypes.add('OutputType');
      break;
    case 'Receipt':
      usedTypes.add('ReceiptType');
      break;
  }

  let imports = `import { SubjectBase } from "../subject-base";\n`;
  imports += `import { ${entity}Parser } from "../../parsers";\n`;
  imports += `import type { ${Array.from(usedTypes).sort().join(', ')} } from "../../types";\n`;

  return imports;
}

function generateSubjectClass(
  name: string,
  format: string,
  isGeneric: boolean,
  entity: string,
  id: string,
) {
  const className = `${name}Subject`;
  const interfaceName = `${name}Fields`;

  if (isGeneric) {
    return `export class ${className} extends SubjectBase<${interfaceName}, ${entity}, Raw${entity}> {
  metadata = {
    id: "${id}",
    format: "${format}",
    parser: new ${entity}Parser(),
  };
}`;
  }

  return `export class ${className} extends SubjectBase<${interfaceName}, ${entity}, Raw${entity}> {
  metadata = {
    id: "${id}",
    format: "${format}",
    parser: new ${entity}Parser(),
  };
}`;
}

function getUsedTypes(fields: Record<string, any>): Set<string> {
  const usedTypes = new Set<string>();

  Object.values(fields).forEach((value) => {
    const mappedType = mapRustTypeToTS(value.type);
    if (
      [
        'Address',
        'AssetId',
        'BlockHeight',
        'Bytes32',
        'ContractId',
        'IdentifierKind',
        'TransactionStatus',
        'TransactionKind',
        'MessageId',
        'UtxoType',
        'TxId',
        'HexData',
      ].includes(mappedType)
    ) {
      usedTypes.add(mappedType);
    }
  });

  return usedTypes;
}

async function generateModuleSubjects(_moduleName: string, moduleConfig: any) {
  // Generate list of subjects in this file
  const subjectNames: string[] = [];
  const entity = moduleConfig.entity;

  // Always add the main subject first
  subjectNames.push(moduleConfig.subject);

  // Add variant subjects if they exist
  if ('variants' in moduleConfig) {
    Object.values(moduleConfig.variants).forEach((variant: any) => {
      subjectNames.push(variant.subject);
    });
  }

  // Generate header comment
  let content = `/**
 * This file is auto-generated by scripts/generate-subjects.ts
 * Do not edit this file manually
 * 
 * Generated Subjects:
 ${subjectNames.map((name) => ` * - ${name}`).join('\n')}
 */\n\n`;

  // Add imports using the new function
  content += `${generateSubjectImports(moduleConfig, entity)}\n`;

  if ('variants' in moduleConfig) {
    // Generate main subject
    const baseName = v.replaceAll(moduleConfig.subject, 'Subject', '');
    content += generateInterface(baseName, moduleConfig.fields);
    content += '\n\n';
    content += generateSubjectClass(
      baseName,
      moduleConfig.format,
      false,
      entity,
      moduleConfig.id,
    );
    content += '\n\n';

    // Generate variants
    Object.entries(moduleConfig.variants).forEach(
      ([_, variant]: [string, any]) => {
        const variantBaseName = v.replaceAll(variant.subject, 'Subject', '');
        content += generateInterface(variantBaseName, variant.fields);
        content += '\n\n';
        content += generateSubjectClass(
          variantBaseName,
          variant.format,
          false,
          entity,
          variant.id,
        );
        content += '\n\n';
      },
    );
  } else {
    const baseName = v.replaceAll(moduleConfig.subject, 'Subject', '');
    content += generateInterface(baseName, moduleConfig.fields);
    content += '\n\n';
    content += generateSubjectClass(
      baseName,
      moduleConfig.format,
      false,
      entity,
      moduleConfig.id,
    );
  }

  return content;
}

function generateMainIndex() {
  return `/**
 * This file is auto-generated by scripts/generate-subjects.ts
 * Do not edit this file manually
 */

${Object.keys(subjectsDefinitions)
  .map((moduleName) => `export * from "./${v.lowerCase(moduleName)}/subjects";`)
  .join('\n')}
`;
}

async function generateAllSubjects() {
  try {
    console.log(`Generating subjects in: ${OUTPUT_DIR}`);

    // Generate subject-base.ts file
    const baseContent = generateSubjectBase();
    const basePath = path.join(OUTPUT_DIR, 'subject-base.ts');
    fs.writeFileSync(basePath, baseContent);
    console.log(`Generated: ${basePath}`);

    // Generate module files
    await Promise.all(
      Object.entries(subjectsDefinitions).map(async ([moduleName, config]) => {
        const moduleDir = path.join(OUTPUT_DIR, v.lowerCase(moduleName));
        fs.mkdirSync(moduleDir, { recursive: true });
        console.log(`Created module directory: ${moduleDir}`);

        // Generate subjects.ts
        const subjectsContent = await generateModuleSubjects(
          moduleName,
          config,
        );
        const subjectsPath = path.join(moduleDir, 'subjects.ts');
        fs.writeFileSync(subjectsPath, subjectsContent);
        console.log(`Generated: ${subjectsPath}`);
      }),
    );

    // Generate main index.ts file
    const mainIndexContent = generateMainIndex();
    const mainIndexPath = path.join(OUTPUT_DIR, 'index.ts');
    fs.writeFileSync(mainIndexPath, mainIndexContent);
    console.log(`Generated: ${mainIndexPath}`);

    // Format all files
    console.log('\nFormatting generated files...');
    await $`biome format --write ${OUTPUT_DIR}`;

    console.log('\nSuccessfully generated and formatted all files!');
  } catch (error) {
    console.error('Error generating files:', error);
    process.exit(1);
  }
}

// Run the generator
generateAllSubjects();
